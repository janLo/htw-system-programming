\documentclass[pdftex,final,a4paper,10pt,notitlepage,halfparskip]{scrreprt}

\usepackage[german,ngerman]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[babel,german=quotes]{csquotes}
\usepackage{fancybox}
\usepackage{color}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{floatflt}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{listings}

\setkomafont{caption}{\footnotesize\linespread{1}\selectfont}
\setlength{\abovecaptionskip}{-0.1cm}
\addto\captionsngerman{\renewcommand\figurename{Abb.}}

\title{Systemprogrammierung\\
- Beleg 3 -}
\author{Jan Losinski}

\begin{document}

\maketitle

\tableofcontents

\chapter{Allgemeines}
\section{Aufgabe}
Entwickeln Sie, in C, C++ (oder Perl), einen "`nutzerfreundlichen"' und "`robusten"' SMTP-Server.

Der Server soll den Clients "{u}ber eine Socketverbindung (freier Port) die SMTP-Kommandos in einer einfachen, verst"{a}ndlichen Form bereitstellen/anfordern, die Eingaben pr"{u}fen, zusammenstellen und zum Senden der Mail an einen SMTP-Server (z.B. mail.informatik.htw-dresden.de, Postfix) schicken. 

Dazu ist ebenfalls eine eigene Socketverbindung zu nutzen, die Nutzung von Kommandos wie mail oder sendmail ist nicht zul"{a}ssig. Dies ist auch nicht m"{o}glich, da der Client, im Sinne der Nutzerfreundlichkeit, eine Sendequittung (zum Test ev. gesamtes Protokoll), erhalten soll. Ob die Kommandos als ein gesamter String oder einzeln gesendet werden, ist freigestellt.

Als Client kann telnet genutzt werden.

Der Server soll gleichzeitig mit mehreren Clients arbeiten k"{o}nnen, daf"{u}r sind Threads zu nutzen.

\section{Herangehensweise}
Die Aufgabenstellung beschreibt ein simples SMTP Relay, welches E-Mails per SMTP annimmt und einfach weiterleitet. Das macht es n"{o}tig, sowohl die Grundfunktionalit"{a}ten eines SMTP Servers(annahme), als auch die eines Clients (forward) zu implementieren.

Bei der weiteren Analyse der Aufgabe wurde festgestellt, das diese bei der Implmentierung in 4 Module aufgeteilt werden kann:
\begin{description}
  \item[smtprelay]
    Dies beherbergt die main Funktion, k"{u}mmert sich um das parsen der Kommandozeilenoptionen, inkl. nachschlagen der Hostnamen. Zudem ist es f"{u}r die Fehlerausgabe verantwortlich. (Listing \ref{smtprelay.c}, \ref{smtprelay.h}) 
  \item[connection] 
    Dies ist f"{u}r die komplette Verbindungsverwaltung inkl. der Erzeugung neuer Client Threads zust"{a}ndig (Listing \ref{connection.c}, \ref{connection.h})
  \item[session] 
    Dieses Modul implementiert eine Client-Session. Es beherbergt den kompletten Code zur Kommunikation mit einem Client. (Listing \ref{session.c}, \ref{session.h})
  \item[sender] 
    Das sender Modul ist f"{u}r die Kommunikation mit dem remote Server zust"{a}ndig, an welchen die E-Mails weitergeleitet werden. (Listing \ref{sender.c}, \ref{sender.h})
\end{description}

Das Ziel war, ein einzelnes Binary zu schaffen, welches mittels Kommandozeilen-Optionen konfigurierbar ist und die komplette, in der Augabenstellung geforderte, Funktionalit"{a}t abdekt.

\section{Build}\label{build}
Zu dem entstandenen Programm existiert ein Makefile (Listing \ref[Makefile]), welches vier wichtige Targets kennt:
\begin{description}
  \item[binary] Baut das normale Programm, hier sind die Ausgaben w"{a}hrend der Laufzeit auf kritische Fehler reduziert. 
  \item[debug] Baut eine Debug-Version des Programmes, welche w"{a}hernd der Laufzeit besonders viele Informationen ausgeben kann .
  \item[all] Baut sowohl die debug Version des Programms, als auch die normale, nicht-debug Version.
  \item[clean] L"{o}scht alle Object-Dateien und die erzeugten Binarys. 
\end{description}
Das zu erstellende Target kann mittels \texttt{make <target>} erzeugt werden. Wird hinter \texttt{make} kein Target angegeben, so wird \texttt{make all} ausgef"{u}hrt.



\chapter{Nutzung}
\section{Server}
Der Server ist ein einfaches Programm, welchen auf der Kommandozeile ausgef"{u}hrt werden kann.

Er wird komplett "{u}ber die Kommandozeile konfiguriert und kennt dabei folgende Optionen:
\begin{description}
  \item[-q] Schaltet in den quiet Mode, in welchem die Fehlerausgaben ausgeschaltet sind.
  \item[-v] Schaltet den verbose Mode ein, in welchem besonders viele Informationen ausgegeben werden. Diese Option ist jedoch nur in der debug Version vorhanden (siehe \ref{build})
  \item[-a <bind\_address>] Mit diesem Schalter wird die Addresse angegeben, an die der Server gebunden werden soll. Um die standartm"{a}ßig eingesttelle Addresse zu erfahren f"{u}hren Sie bitte das Programm mit dem Schalter \texttt{-h} aus. 
  \item[-p <bind\_port>] Mit diesem Schalter geben Sie den Port an, an den der Server gebunden werden soll. Auch hier wird der Standardwert durch den Schalter \texttt{-h} ausgegeben.
  \item[-d <remote\_address>] Hiermit kann die Addresse des Remoteservers, an den alle eingehenden E-Mails weitergeleitet werden, angegeben werden. Der Standartwert wird mit dem Schalter \texttt{-h} ausgegeben.
  \item[-r <remote\_port>] Dieser Schalter dient zur Eingabe sed Remoteports, also des Ports, an dem der Remoteserver lauscht. Dtandartwerte sind mit \texttt{-h} zu erfragen.
  \item[-h] Gibt einen Hilfetext mit allen Standartwerten aus. 
\end{description}
Addressen die <bind\_address> k"{o}nnen dabei sowohl als IP Addresse, als auch als Hostname angegeben werden.

Wurde das Programm korrekt ausgef"{u}hrt, so lauscht es auf dem angegebenem Port und wartet auf Clients.

Der Remoteserver muss ein SMTP Server sein, welcher Mindestens die Kommandos \texttt{HELO}, \texttt{MAIL FROM}, \texttt{RCPT TO}, \texttt{DATA} und \texttt{QUIT} versteht. Der Datenblock wiederum muss mit \texttt{<CR><LF>.<CR><LF>} abschließbar sein.

\section{Client}
Der Client muss die wichtigsten SMTP Kommandos beherrschen. Implementiert sind:
\begin{description}
  \item[HELO <client\_name>] Anmeldung des Clients.
  \item[MAIL FROM:<mail\_addr>] Angabe des Absenders.
  \item[RCPT TO:<mail\_addr>] Angabe des Empf"{a}ngers.
  \item[DATA] Beginn des Datenblocks (Ende mit \texttt{<CR><LF>.<CR><LF>}).
  \item[QUIT] Beenden der Verbindung.
  \item[RSET] R"{u}cksetzten der Verbindung bis nach \texttt{HELO}. 
  \item[NOOP] Gibt immer eine 250 zur"{u}ck (zum Bsp. zum Testen der Verbindung).
\end{description}

Dabei muss eine Normale Sitzung immer nach dem SMTP-Protokoll (siehe \ref{rfc2821}) ablaufen. Das heißt, das zuerst immer ein \texttt{HELO} kommen muss, dann beliebig viele Mailbl"{o}cke, wobei ein Mailblock aus \texttt{HELO}$\rightarrow$\texttt{RCPT TO}$\rightarrow$\texttt{DATA}$\rightarrow$<Datenblock mit abschließendem \texttt{<CR><LF>.<CR><LF>}> besteht, und abschließend ein \texttt{QUIT}.

Die Replycodes des Servers sind entsprechend dem SMTP Standard (siehe \ref{rfc2821}) implementiert.

\chapter{Programmdokumentation}
\section{Modul smtprelay}\label{mod:smtprelay}
\subsection{Beschreibung}
Hier sind alle Funktionen definiert, die vor der Öffnung des Sockets aufzurufen sind. Außerdem ist die die Fehlerausgabe, sowie die debug Ausgabe (im Header) definiert. 

Die Debugausgabe ist durch mehrere Makros realisiert, welche nur dann einen Effekt haben, wenn die debug Variante des Programmes gebaut wird (siehe \ref{build}). Die Makros haben alle unterschiedliche Argumente, je nachdem was ausgegeben werden soll. Zudem sind sie noch unterteilt in normale und DEBUG\_CLNT Makros, welche zusätzlich noch die aktuelle Threadid ausgeben.

Die Quellen sind in den Listings \ref{smtprelay.c} und \ref{smtprelay.h} aufgeführt.

\subsection{Funktion main}\label{fn:main}
Die Main Funktion ist die Funktion, welche im Programm als erstes aufgerufen wird. Sie stellt den Startpunkt des Programms dar.

Hier werden zuerst die Interupt Handler installiert, welche dafür sorgen, dass der Server Socket auch ordnungsgemäß geschlossen wird. Anschließend wird die Funktion \ref{fn:process_opt} zum verarbeiten der Kommandozeilenargumente aufgerufen und \ref{fn:create_conn} aus \ref{mod:connection} aufgerufen um den Socket zu kreieren.

Wenn diese Funktion zurückkehrt wird das Programm beendet.

\subsection{Funktion process\_opt}\label{fn:process_opt}
Diese Funktion wertet mittels getopt und den Funktionen \ref{fn:host_opt} und \ref{fn:port_opt} die Kommandozeilenargumente aus, schreibt diese in die globale Variable app, in der alle Konfigurationsdaten gehalten werden und ruft bei Bedarf die Funktion zur Aufgabe der Hilfe \ref{fn:write_help} auf.

Die Rückgabe ist im Erfolgsfall OK, sonst FAIL (beide Werte definiert in Listing \ref{smtprelay.h})

\subsection{Funktion write\_help}\label{fn:write_help}
Diese Funktion dient dazu, eine Hilfe zur Programmbenutzung auszugeben.

\subsection{Funktion host\_opt}\label{fn:host_opt}
Diese Funktion dient dazu, die Addressargumente zu prüfen und umzuwandeln.

Das Argument \texttt{buff} beinhaltet dabei das Kommandozeilenargument und \texttt{err} eine Fehlermeldung, welche ausgegeben werden soll, wenn das Argument nicht valide ist.

Wird festgestellt, das das Argument eine IP Addresse war, so wird diese in einen neuen Speicherbereich kopiert und dessen Addresse zurückgegeben.

Ansonsten wird versucht, das Argument als Hostnamen zu nutzen und per \texttt{gethostbyname} die zugehörige IP Addresse zu ermitteln. Gelingt dies, so wird die IP Addresse als String in einen neuen Speicherbereich geschrieben und dessen Addresse zurückgegeben.

Sollte es nicht möglich sein, eine IP Addresse zu ermitteln, so wird NULL zurückgegeben.
\subsection{Funktion port\_opt}\label{fn:port_opt}
Diese Funktion dient dazu eine per Kommandozeile übergebene Portnummer auf Gültigkeit zu prüfen.

Das Argument \texttt{buff} beinhaltet dabei das Kommandozeilenargument und \texttt{err} eine Fehlermeldung, welche ausgegeben werden soll, wenn das Argument nicht valide ist.

Ist die übergebene Option eine valide Portnummer, dann wird diese in einen neuen Speicherbereich geschrieben und dessen Adresse zurückgegeben, sonst NULL.

\subsection{Funktion put\_err}\label{fn:put_err}
Diese Funktion dient zur Ausgabe eines Fehlers. Dabei wird zuerst das übergebene Argument inklusive der in \texttt{ERROR\_PREF} definierten Formatierung und anschließend der zu \texttt{errno} gehörende Fehlertext mittels \texttt{perror} auf \texttt{stderr} ausgegeben.

\subsection{Funktion put\_err\_str}\label{fn:put_err_str}
Diese Funktion gibt einfach den im Argument übergebenen Fehlertext inklusive der in \texttt{ERROR\_PREF} definierten Formatierung auf \texttt{stderr} ausgegeben.

\section{Modul connection}\label{mod:connection}
\subsection{Beschreibung}
Das Modul connection beherbergt alle Funktionen, die sich mit den Socketverbindungen beschäftigt. Dies bezieht sich sowohl auf die Verbindungen zu den Clients, als auch der zum remote Server.

Zudem werden hier die neuen Threads für die Clients erzeugt, da jeder Client seinen eigenen Thread bekommt. Auch der Interupt handler ist hier definiert, da in diesem die Socketverbindung des Servers beendet werden muss.

Die Quellen sind in den Listings \ref{connection.c} und \ref{connection.h} aufgeführt.




\subsection{Funktion create\_socket}\label{fn:create_socket}
Dies erzeugt einen neuen Inet Socket, welcher hier auch gleich an die richtige Addresse gebunden wird.

\subsection{Funktion process\_client}\label{fn:process_client}
Dies ist die erste Funktion, die im neuen Thread aufgerufen wird.

Sie startet mittels \ref{fn:start_session} die Client Session, und schließt den Client Socket wenn die Session beendet wurde.

\subsection{Funktion wait\_connect}\label{fn:wait_connect}
Hier wird auf Client Verbindungen gewartet. 

Kommt solch eine zustande, so wird ein neuer Thread gestartet und in diesem die Funktion \ref{fn:process_client} zum starten einer neuen Sitzung aufgerufen.

Der neue Thread wird gleich mittels \texttt{pthread\_detach} detacht, um Speicherlöchern durch nicht aufgeräumte Threads vorzubäugen.

\subsection{Funktion create\_conn}\label{fn:create_conn}
Diese Funktion dient zum öffnen des Socket. Sie bekommt Hostname und Port zum binden übergeben und generiert daraus eine \texttt{sockaddr\_in}.

Dann wird der Socket mit \ref{fn:create_socket} geöffnet und mit \ref{fn:wait_connect} auf Clients gewartet.

Am Ende wird mit \ref{fn:quit_conn} die Verbindung beendet (sollte nie passieren, da das Warten nur durch ein Signal oder einen Fehler unterbrochen wird).


\subsection{Funktion quit\_conn}\label{fn:quit_conn}
Diese Funktion schließt die als Filedescriptor übergebene Socketverbindung.


\subsection{Funktion create\_remote\_conn}\label{fn:create_remote_conn}
Diese Funtion baut eine Verbindung zu dem Remoteserver auf, an den die Mails weitergeleitet werden sollen. Zurückgegeben wird der Filedescriptor des Sokets, \texttt{-1} sonst.

Die Verbindungsdaten (IP Addresse, Portnummer) werden als Argumente an die Funktion übergeben.

\subsection{Funktion quit\_remote\_conn}\label{fn:quit_remote_conn}
Diese Funktion schließt die als Filedescriptor übergebene Socketverbindung.

\subsection{Funktion sig\_abrt\_conn}\label{fn:sig_abrt_conn}
Dies ist der Signal Handler, der aufgerufen wird, wenn eines der Signale \texttt{SIGABRT}, \texttt{SIGTERM}, \texttt{SIGQUIT} oder \texttt{SIGINT} eintifft. 

Sie schließt den Server Socket und beendet das Programm.





\section{Modul session}\label{mod:session}
\subsection{Beschreibung}
Im Modul session sind die Funktionen definiert, die zur Kommunikation mit dem Client nötig sind. 

Dazu gehört die Ein- und Ausgabe auf dem Client Socket, die Abarbeitung der im SMTP Protokoll definierten Kommandosequenzen sowie das Testen der Eingaben des Clients.

Die Quellen sind in den Listings \ref{session.c} und \ref{session.h} aufgeführt.

\subsection{Funktion write\_client\_msg}\label{fn:write_client_msg}
Diese Funktion schreibt eine Ausgabe auf den Socket. Die Nachricht ist ein im Header des Modules session \ref{session.h} definierter Formatstring (\texttt{MSG\_*}), in den der als Argument übergebene Replycode, sowie ein optionales String Argument eingebaut wird.

Zurückgegeben wird bei Erfolg \texttt{OK}, sonst \texttt{FAIL} (definiert in \ref{smtprelay.h}).

\subsection{Funktion check\_addr}\label{fn:check_addr}
Diese Funktion überprüft eine vom Client angegebene Hostaddresse. 

Da dieses Programm lediglich ein Relay sein soll, welches keine Mails ausliefern soll ist es nicht nötig, des Hostnamen auf Existenz zu prüfen. Es wird lediglich geprüft, ob min. zwei Zeichen eingegeben wurden. 

Die genauere Überprüfung wird dann dem Remote Server überlassen.

Ist zu einem späterem Zeitpunkt eine komplexere Prüfung nörig, so ist dies an dieser Stelle sehr einfach Implementierbar.

\subsection{Funktion check\_mail}\label{fn:check_mail}
Diese Funktion ist, analog zu \ref{fn:check_addr} für das Testen einer eingegebenen Mailaddresse zuständig. 

Dabei wird einfach geprüft, ob eine mindestens 3 Zeichen lange Zeichenkette, gefolgt von einem @ und einem Hostnamen, welcher die Überprüfung in Funktion \ref{fn:check_addr} besteht, eingegeben wurde.

Eine genauere Überprüfung wird auch hier dem Remote Server überlassen, ist aber an dieser Stelle einfach implemetierbar.

\subsection{Funktion check\_input}\label{fn:check_input}
Diese Funktion testet eine vom Client stammende gelesene Zeile.

Dazu bekommt sie die gelesene Zeile, ein SMTP Kommando, das erwartet wird, ein Trennzeichen, mit dem das Kommando vom restlichem String getrennt ist, eine Funktion, mit der das Argument des Kommandos überprüft wird und eine Addresse, an die das Argument geschrieben werden soll übergeben.

Zuerst wird überprüft, ob das Trennzeichen im String zu finden ist. Ist dies nicht der Fall, so wird \texttt{CHECK\_DELIM} zurückgegeben.

Anschließend wird getestet, ob der gelesene String das erwartete Kommando ist, wenn nicht wird \texttt{CHECK\_PREF} zurückgegeben.

Dann wird geprüft, ob das Tennzeichen ein nicht-Nullterminierungszeichen war. Im Erfolgsfall wird getestet, ob die Länge des Arguments größer 0 ist (sonst wird \texttt{CHECK\_ARG} zurückgegeben) und wenn ja, ob die Testfunktion (wenn angegeben) einen positiven Rückgabewert zurückgibt. Ist dies nicht der Fall, wird die Funktion mit \texttt{CHECK\_ARG} oder \texttt{CHECK\_ARG\_MSG} beendet.

Wurden alle Tests passiert, so wird das Atgument in einen neuen Speicherbereich geschrieben und \texttt{CHECK\_OK} zurückgegeben.

\subsection{Funktion fetch\_input\_line}\label{fn:fetch_input_line}
Diese Funktion holt über den Socket eine Zeile vom Client. Als Argumente bekommt sie den Filedescriptor der Socketverbindung, ein SMTP Kommando, das erwartet wird, ein Trennzeichen, mit dem das Kommando vom restlichem String getrennt ist, eine Funktion, mit der das Argument des Kommandos überprüft wird und eine Addresse, an die das Argument geschrieben werden soll übergeben.

Zuerst wird die Zeile vom Socket gelesen und diese mittels \ref{fn:check_input} geprüft, ob es sich um die erwartete Zeile handelt. Ist dies der Fall, so wird \texttt{READ\_OK} zurückgegeben. Schlägt die Überprüfung des Argumentes in \ref{fn:check_input} fehl, so wird ein fehler an den Client geschickt und erneut auf eine Zeile gewartet.

Handelt es sich bei der gelesenen Zeile nicht um die erwartete, so wird (ebenfalls mit \ref{fn:check_input}) geprüft, ob es sich um ein \texttt{RSET}, \texttt{QUIT}, \texttt{NOOP} oder eines der nicht implementierten Kommandos \texttt{VRFY}, \texttt{EXPN} bzw. \texttt{HELP} handelt. Zum schluss wird noch getestet, ob es sich um ein anderes SMTP Kommando kandelt, welches an dieser Stelle nicht erwartet wurde.
\begin{itemize}
  \item Bei \texttt{RSET} wird eine Meldung ausgegeben, das erfolgreich zurückgesetzt wurde und \texttt{READ\_RESET} zurückgegeben. 
  \item Bei \texttt{QUIT} wird eine Abschiedsnachricht an den Client gesandt und \texttt{READ\_QUIT} zurückgegeben. 
  \item Bei \texttt{NOOP} Wird eine kurze Nachricht an den Client gesandt und auf die nächste Zeile gewartet.
  \item Bei einem der unimplementierten Kommandos wird eine Meldung an den Client geschickt, dass dieses Kommando nicht implementiert ist und auf die nächste Zeile gewartet.
  \item Bei einem unerwartetem Kommando wird ausgegeben, dass es sich um eine  falsche Kommandosequenz handelt und auf die nächste Zeile gewartet.
  \item Wenn die Eingabe keinem Kommando zugeordnet werden konnte wird eine Fehlermeldung an den Client geschickt, dass die Syntax falsch sei und auf die nächste Zeile gewartet. 
\end{itemize}

Bei Lesefehlern auf dem Socket wird \texttt{READ\_ERR} zurückgegeben und ein Fehler ausgegeben.

\subsection{Funktion read\_data}\label{fn:read_data}
Diese Funktion dient dazu, den Datenblock einer Mail zeilenweise zu lesen und daraus eine Liste vom Typ \texttt{data\_line\_t} zu generieren.

Sie überprüft die Eingabe auch auf das Terminierungszeichen \texttt{<CR><LF>.<CR><LF>} und beendet an dieser Stelle den Datenblock.


\subsection{Funktion session\_sequence}\label{fn:session_sequence}
Diese Funktion dient dazu, eine Mail Sequenz (\texttt{MAIL FROM} $\rightarrow$ \texttt{RCPT TO} $\rightarrow$ \texttt{DATA} $\rightarrow$ Daten $\rightarrow$ \texttt{<CR><LF>.<CR><LF>}) anzuarbeiten.

Dazu wird mit \ref{fn:fetch_input_line} auf das entsprechende Kommando bzw. mit \ref{fn:read_data}auf Daten gewartet und jeweils eine Statusnachricht zurückgegeben.

Bei Fehlern wird mit \texttt{SESSION\_ABORT} abgebrochen. Ein empfangenes \texttt{QUIT} lässt die Funktion ein \texttt{SESSION\_QUIT} und \texttt{RSET} ein \texttt{SESSION\_RESET} zurückgeben. Bei erfolgreich abgearbeiteter Mail Sequenz wird \texttt{SESSION\_SEND} zurückgegeben.

\subsection{Funktion start\_session}\label{fn:start_session}
Dies ist die Funktion, die eine Mailsession für einen Client startet. Sie wird dabei vin \ref{fn:process_client} aus dem Modul \ref{mod:connection} aufgerufen.

Sie begrüßt den Client, wartet auf sein \texttt{HELO}, dtartet mit \ref{fn:session_sequence} die Mail Sequenzen, übernimmt die Behandlung der Rückgabewerte (rücksetzten, beenden oder abbrechen der Verbindung) und schickt mittels \ref{fn:forward_mail} die Mail schließlich an den remote Server.



\section{Modul sender}\label{mod:sender}
\subsection{Beschreibung}
Das Modul sender definiert alle Funktionen zur Kommunikation mit dem Remoteserver.

Dazu gehört das Senden der Kommandos, das auswerten der Replys sowie das mittschreiben eines Protokolls in form einer Liste vom Typ \texttt{data\_list\_t}, welches dem Client dann in dem abschließendem Reply ausgegeben wird.

Die Quellen sind in den Listings \ref{sender.c} und \ref{sender.h} aufgeführt.

\subsection{Funktion new\_proto\_entry}\label{new_proto_entry}
Diese Funktion generiert aus der übergebenen Zeichenkette ein neues Element vom Typ \texttt{data\_list\_t} für das Protokoll.

\subsection{Funktion wind\_proto}\label{wind_proto}
Diese Funktion bekommt einen Pointer vom Typ \texttt{data\_line\_t}, welcher auf einen beliebigen Protokolleintrag zeigt und gibt einen Pointer vom gleichem Typ zurück, der auf das letzte Element des Protokolls zeigt.

\subsection{Funktion read\_remote}\label{read_remote}
Dies ist eine Wrapperfunktion für \texttt{read}, die zusätzlich die Fehlerausgabe und das mittscreiben des Protokolls übernimmt.

\subsection{Funktion write\_remote}\label{write_remote}
Dies ist eine Wrapperfunktion für \texttt{write}, die zusätzlich die Fehlerausgabe und das mittscreiben des Protokolls übernimmt.

\subsection{Funktion free\_protocol}\label{free_protocol}
Die Funktion \texttt{free\_protocol} bekommt den Pointer auf das Protokoll übergeben und gibt dessen Speicher Eintrag für Eintrag wieder frei.

\subsection{Funktion extract\_status}\label{extract_status}
Diese Funktion extrahiert aus einem, vom Remoteserver, empfangenem Sting den Replycode und gibt ihn als \texttt{int} zurück.

\subsection{Funktion try\_command}\label{try_command}
Diese Funktion sendet ein SMTP Kommando mittels \ref{write_remote} an den Remoteserver und wartet die Antwort ab: 
\begin{itemize}
  \item Ist die ampfangene Antwort wie erwartet, so wird \texttt{COMMAND\_OK} zurückgegeben. 
  \item Ist der empfangene Replycode ein 4xx Code, so wird (max. \texttt{SEND\_MAXTRY} mal) versucht das Kommando erneut zu senden. 
  \item Ist der Replycode ein anderer oder \texttt{SEND\_MAXTRY} Versuche schief gegangen, so wirf \texttt{COMMAND\_FAIL} zurückgegeben.
\end{itemize}
Zudem werden Lese und schreibfehler abgefangen.


\subsection{Funktion send\_mail}\label{send_mail}
Diese Funktion schickt die im SMTP Protokoll (siehe \ref{rfc2821}) definierte Kommandosequenz (\texttt{HELO} $\rightarrow$ \texttt{MAIL FROM} $\rightarrow$ \texttt{RCPT TO} $\rightarrow$ \texttt{DATA} $\rightarrow$ Daten $\rightarrow$ \texttt{<CR><LF>.<CR><LF>} $\rightarrow$ \texttt{QUIT}) zum versenden der E Mail an den Remoteserver.










\begin{appendix}
  \chapter{Anhang}
  \section{Quellen}

  \lstset{language=[ANSI]C, 
      keywordstyle=\color{blue!80!black!100}, 
      identifierstyle=, 
      commentstyle=\color{green!50!black!100}, 
      stringstyle=\ttfamily, 
      breaklines=true, 
      columns=fixed,
      numbers=left, 
      framexleftmargin=20pt,
      numbersep=9pt,
      numberstyle=\tiny, 
      frame=single, 
      caption={C-Code} 
      backgroundcolor=\color{Beige}, 
      % basicstyle=\small\ttfamily\bfseries, % print whole listing small 
      basicstyle=\scriptsize\ttfamily\bfseries, % print whole listing small 
      linewidth=\linewidth,       % Zeilenbreite 
      breaklines=true,
      showstringspaces=false,
      breakatwhitespace=true, %Umbruch an Leerzeichen 
      captionpos=b 
  }


  \subsection{smtprelay}
  \lstinputlisting[caption=smtprelay.c,label=smtprelay.c]{../smtprelay.c}
  \pagebreak
  \lstinputlisting[caption=smtprelay.h,label=smtprelay.h]{smtprelay.h}
  \pagebreak
  \subsection{connection}
  \lstinputlisting[caption=connection.c,label=connection.c]{../connection.c}
  \pagebreak
  \lstinputlisting[caption=connection.h,label=connection.h]{../connection.h}
  \pagebreak
  \subsection{session}
  \lstinputlisting[caption=session.c,label=session.c]{../session.c}
  \pagebreak
  \lstinputlisting[caption=session.h,label=session.h]{../session.h}
  \pagebreak
  \subsection{sender}
  \lstinputlisting[caption=sender.c,label=sender.c]{../sender.c}
  \pagebreak
  \lstinputlisting[caption=sender.h,label=sender.h]{../sender.h}
  \pagebreak
  \subsection{Makefile}
  \lstinputlisting[caption=Makefile,label=Makefile]{../Makefile}

  \section{SMTP Standard}
  \lstset{numbers=none,
      basicstyle=\scriptsize\ttfamily\bfseries, % print whole listing small 
      formfeed=\pagebreak,
      showstringspaces=false,
      language=[plain]TeX}
%  \lstinputlisting[caption=SMTP Standard: RFC 2821,label=rfc2821]{rfc2821.txt}


\end{appendix}

\end{document}
